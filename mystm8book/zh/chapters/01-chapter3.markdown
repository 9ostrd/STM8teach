# 软件开发那点事 #
下面这些东西,是我在软件方面的书籍和实践中学习到的一点心得.之前学习嵌入式的时候,并没有接触到相关的知识.

## 使用版本控制管理工具 ##
你是否有这样一种经历?当你在电脑上辛辛苦苦赶项目，马上就要做完了，但是因为突发情况（比如停电什么的），一瞬间，所有的工作都得从头开始，你欲哭无泪。于是，在几次这样的悲剧发生后，你吸取了教训，开始备份。比较原始的备份策略[^3]就是本工作文件定期复制到某个文件夹中，但过不久你就会发现，你已经分不清哪个是你最新版本的工作文件了。接着你以*《文件名_编辑时间》*的方式，把文件存放在同一路径下，这样似乎好一些了，但是如果整个硬盘遭受物理性损坏，所有备份的数据就一起陪葬了。似乎raid是一个好的解决方案，但是对于一般用户来说似乎又不太能够承受，而且，过于复杂的操作，会降低用户备份的积极性。可能你每天修改3、4次文件，但是却半个月才想到要备份一次。

[^3]:一般有备份意识的人还是少的，本人即使在保持备份的意识下，也曾经因为一些原因丢失工作数据，造成一些尴尬情况的。

那么什么是这个问题的优秀解决方案？回答是版本控制软件。他们具有对数据的存储、追踪、回退等诸多功能，方便好用。并且，github、google code等网站，有着高可靠的硬件支撑，为数据的安全性、可靠性，提供了有利的保证。通过其提供的免费或者付费服务，可以使用各种版本控制软件，如CVS、SVN、Git……能够在对你的代码、数据进行方便管理的同时，保证安全性。

### 使用Git来管理你的项目 ###
Git是linus写的，它的诞生一开始是为了管理linux的内核。linus说过一句话，大概意思是SVN的用户是可悲的[^4]，不管Git有没有那么强大，首先能让linus说出这种话，就说明Git是有杀手锏的。Git的优势在于快速、免费，当然，最重要的是，Git是分布式的，也就是说软件库是保存在用户本地，而非像clearcase、SVN这样，保存在远程服务器上。这样，就方便用户能够随时接触到代码。而且万一远程服务器出现故障，利用用户的数据也能基本恢复服务端的数据，数据的安全性更有保障。现在很多项目已经转移到Git上了，著名的有：[linux内核](https://github.com/torvalds/linux)，[groovy](https://github.com/groovy/groovy-core),[pandoc](https://github.com/jgm/pandoc)等等……

[^4]:SVN也是一个相当著名的版本管理系统

如果想学git，以下这些事情是必须的：

*在Github上建立一个账户。Github是一个支持Git的项目托管网站。有很多程序员使用该网站对自己的项目进行管理，并且与网友协作开发。价格方面，如果你的项目是开源的，那么一切都是免费的。

如果是第一次安装，配置环境的图文教程可以在<http://help.github.com/win-set-up-git/>找到。同时[Github的帮助网站](http://help.github.com/)上面有关于Git的详细帮助。

当然如果需要系统的学习，[《PROGIT》](http://progit.org/)这本书就是一个比较详尽的教程。

等用完一段时间再来看看这里吧，看看你能不能自己写一篇Git Guide了？

## 说说IDE ##
平时经常可以听到IDE，这个名字。那么IDE到底是什么呢？

IDE的全称是： **I**ntegrated **D**evelopment **E**nvironment。我们平时写程序，无外乎编辑——编译——连接的过程，出故障了也许要做软/硬件单步调试。IDE给我们写程序，提供了上面这个流程中，所需要的一切。PC机上的Visual studio，51上的KEIL，AVR上的AVRstudio等等，都是IDE。

### IDE的优势 ###
我们大量使用IDE，有一定的原因：一方面因为IDE的安装使用极其方便，网上下好一路next即可，所有需要的工具都在里面，不许要用户自行去寻找。另一方面，IDE所提供的程序经过较好的测试，稳定性可能更高些。

### 尝试着脱离IDE吧 ###
IDE实在太方便了，以至于它把我们用户给惯坏了。沉溺于IDE的人一般只知道把程序写好了，然后在某个菜单，找个buid点一下，然后就可以生成相应的目标文件了。这样一来，整套的编译过程就会被用户抛在脑后。如果在linux下写过一个程序，你就得先用VIM/Emacs编写好程序，然后使用gcc编译，最后连接起来（C语言的程序调试可以用gdb）。对这样的过程不清晰，可能写点小程序还没什么影响，但是碰到大的工程项目，就会一下子摸不着头脑了。

当然更重要的一点是，当我们拿出VC6.0和vs2010的界面比较时，我们会发现他们大相径庭。这就是到现在我们还可以看到为数不少的老师还在教学生vc6.0的原因。图形化的东西，不同版本之间变化太大了，很不利于用户去适应。试想如果你今天学的东西，过两年就过期，谁还去学？！今天你对XXstudio5.0的程序得心应手。过几个月发现主流变成XXstudio6.0了，而且很难马上去适应。但是，非IDE的就没有这个问题。VIM、Emacs、gcc、g++、latex……这些程序历经了数十年的发展，但基本使用方法没有本质的改变，只是增加了功能。

下面是一个C语言的helloworld，很熟悉吧！有条件的可以在linux机器上试一下，需要下linux的，可以去这个网站看看，<www.ubuntu.com>，现在可是很流行哦。本手册的大部分内容可都是在ubuntu环境下编辑的。

~~~~~~~~~~~~~
#include <stdio.h>

int main()
{
	printf("hello world!\n");
	return 0;
}
~~~~~~~~~~~~~

然后`gcc -c filename.c`查看下当前目录里文件，发现多了个filename.o，这个过程就是编译的过程。然后`gcc filename.o -o programName`，会发现目录下多了个可执行文件。最后`./programName`发现程序已经正常执行呢？

### 关于Makefile ###
当然，上面这个生成可执行文件的过程，显然比IDE的要麻烦的多了。IDE下只要点一下，多少事情都解决了。那么非IDE能不能也这么方便呢？

当然可以！linux下的makefile几乎完美地解决了这个问题。

关于Makefile文件的具体语法，以下有个系列文章，在国内应该算是最受欢迎的makefile教程。有人也专门整理成了pdf版本，但本人更加喜欢原汁原味一点的，就是这个了：<http://blog.csdn.net/haoel/article/details/2886>。



## 对开源本身的思考 ##
开源，本身是一个大话题。

有人说，源代码公开了，不是更容易被人找到漏洞了吗？其实不然，因为软件本身在那边，漏洞就在那边。




## 其它参考 ##
